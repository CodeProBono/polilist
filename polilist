#!/usr/bin/env python

import sys
import getopt

import providers.base
DEFAULT_PROVIDER = 'softcache'

import parsers.base
# A dictionary of parsers in use, in the form url:parser.
active_parsers = {'http://www.aph.gov.au/house/members/mi-alpha.asp':'federal_house_of_representatives'}

import exporters.base
DEFAULT_EXPORTER = 'csv'

from util.notifier import *

# Description of how to use this tool.
USAGE_MESSAGE = """Usage: %(progname)s [options] -o output
       %(progname)s [options] --output=output
       %(progname)s [options] --clear-cache
  [ --clear-cache ]                     Clear the selected provider's cache. You should explicitly specify a provider when using this option or you may find that you don't delete the cache you're intending to. You should never need to use this option unless you are developing/debugging.
  [ -d | --debug ]                      Turn on debugging output (equivalent to verbosity level 3).
  [ -e exporter | --exporter=exporter ] Use the specified exporter format (default CSV).
  [ -? | --help ]                       Display this information and exit.
  [ -o output | --output=output ]       Write results to output descriptor output. Note that whether output is a file, directory or other descriptor depends on which exporter you are using.
  [ -p provider | --provider=provider ] Use the specific HTTP provider (default = passthrough).
  [ -v level | --verbosity=level ]      Set the level of verbosity of notifications. 0 = nothing, 1 = default, 2 = detailed, 3 = debug.
""" % {'progname':sys.argv[0]}

def parseArguments(options):
    """
    Parse command line arguments and write the result to the dictionary passed
    in.
    """
    optlist, args = getopt.getopt(sys.argv[1:], 'de:?l:o:p:v:', \
        ['clear-cache', 'debug', 'exporter=', 'help', 'logfile=', 'output=', \
        'provider=', 'verbosity='])

    if args:
        return False

    for opt in optlist:
        if opt[0] == '--clear-cache':
            options['clear-cache'] = True
        elif opt[0] in ['-d', '--debug']:
            options['verbosity'] = DEBUG
        elif opt[0] in ['-e', '--exporter']:
            options['exporter'] = opt[1]
        elif opt[0] in ['-?', '--help']:
            sys.stdout.write(USAGE_MESSAGE)
            sys.exit(0)
        elif opt[0] in ['-l', '--logfile']:
            options['log'] = opt[1]
        elif opt[0] in ['-o', '--output']:
            options['output'] = opt[1]
        elif opt[0] in ['-p', '--provider']:
            options['provider'] = opt[1]
        elif opt[0] in ['-v', '--verbosity']:
            try:
                options['verbosity'] = int(opt[1])
            except ValueError:
                return False

    return True

def main():
    # Setup default options.
    opts = { \
        'clear-cache' :False,            # Clear the provider cache and exit. \
        'exporter'    :DEFAULT_EXPORTER, # Output formatter to use. \
        'log'         :None,             # File to log to (None=std{out|err}). \
        'output'      :None,             # File to export to. \
        'provider'    :DEFAULT_PROVIDER, # HTTP proxy. \
        'verbosity'   :INFORMATION       # Level of notifications printed. \
                                         # (enum in util.notifier) \
    }

    # Parse command line arguments.
    if not parseArguments(opts) or (not opts['output'] and \
        not opts['clear-cache']):
        sys.stderr.write(USAGE_MESSAGE)
        sys.exit(1)

    # Construct the notifier.
    notifier = None
    if opts['log']:
        try:
            f = open(opts['log'], 'w')
            notifier = Notifier(f, f, opts['verbosity'])
        except:
            sys.stderr.write('Failed to open log file %s.\n' % opts['log'])
            sys.exit(1)
    else:
        notifier = Notifier(sys.stdout, sys.stderr, opts['verbosity'])

    # Construct the HTTP provider.
    provider = None
    try:
        provider = getObject('provider', opts['provider'], notifier)
    except Exception as inst:
        notifier.writeError(str(inst), DEBUG)
        notifier.writeError('Could not create %s provider.' \
            % opts['provider'], INFORMATION)
        sys.exit(1)

    # Are we clearing the cache?
    if opts['clear-cache']:
        if hasattr(provider, 'clearCache'):
            try:
                provider.clearCache()
                notifier.write('Cache cleared.', DETAILED)
                sys.exit(0)
            except Exception as inst:
                notifier.writeError(str(inst), DEBUG)
                notifier.writeError('Failed to clear cache.', INFORMATION)
                sys.exit(1)
        else:
            notifier.writeError('The selected provider has no cache or no ' + \
                'ability to clear it.', INFORMATION)
            sys.exit(1)

    # Enumerate the parsers and retrieve contacts' details.
    contacts = []
    for p in active_parsers.keys():
        parser = None
        try:
            parser = getObject('parser', active_parsers[p], notifier, \
                provider=provider)
        except Exception as inst:
            notifier.writeError(str(inst), DEBUG)
            notifier.writeError('Could not create %s parser.' \
                % active_parsers[p], INFORMATION)
            continue

        try:
            contacts.extend(parser.get(p))
        except Exception as inst:
            notifier.writeError(str(inst), DEBUG)
            notifier.writeError('Could not parse %s using parser %s.' \
                % (p, active_parsers[p]), INFORMATION)

    # Export the contacts.
    exporter = None
    try:
        exporter = getObject('exporter', opts['exporter'], notifier, \
            destination=opts['output'])
    except Exception as inst:
        notifier.writeError(str(inst), DEBUG)
        notifier.writeError('Could not create %s exporter.' \
            % opts['exporter'], INFORMATION)
        sys.exit(1)

    try:
        exporter.write(contacts)
    except Exception as inst:
        notifier.writeError(str(inst), DEBUG)
        notifier.writeError('Could not export to %s with exporter %s.' \
            % (opts['output'], opts['exporter']), INFORMATION)
        sys.exit(1)

    if opts['log']:
        try:
            notifier.stdout.close()
        except:
            pass

if __name__ == '__main__':
    main()

